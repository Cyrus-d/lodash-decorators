{"version":3,"file":"bindAll.js","sourceRoot":"","sources":["../src/bindAll.ts"],"names":[],"mappings":";;AAAA,uCAAuC;AACvC,qCAA6C;AAC7C,+BAA8B;AAE9B;;;;;;;;;;;;;;;;;;;;;;GAsBG;AACH,iBAAwB,OAAsB;IAAtB,wBAAA,EAAA,YAAsB;IAC5C,OAAO,UAAC,MAAW;QACjB,cAAc,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;IAClC,CAAC,CAAC;AACJ,CAAC;AAJD,0BAIC;AAkCmB,0BAAO;AAhC3B,wBAAwB,MAAgB,EAAE,OAAsB;IAAtB,wBAAA,EAAA,YAAsB;IAC9D,IAAM,WAAW,GAAG,MAAM,CAAC,SAAS,CAAC;IACrC,IAAI,KAAK,GAAG,MAAM,CAAC,SAAS,CAAC;IAC7B,IAAM,SAAS,GAAa,EAAE,CAAC;IAE/B,OAAO,KAAK,IAAI,KAAK,KAAK,MAAM,CAAC,SAAS,EAAE;QAC1C,KAAkB,UAAiC,EAAjC,KAAA,MAAM,CAAC,mBAAmB,CAAC,KAAK,CAAC,EAAjC,cAAiC,EAAjC,IAAiC,EAAE;YAAhD,IAAM,GAAG,SAAA;YACZ,IAAM,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;YACpE,IAAM,UAAU,GAAG,MAAM,CAAC,wBAAwB,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;YAE/D,IAAI,OAAO,IAAI,GAAG,KAAK,aAAa,EAAE;gBACpC,kEAAkE;gBAClE,2EAA2E;gBAC3E,IAAI,UAAU,CAAC,GAAG,EAAE;oBAClB,IAAM,SAAS,GAAG,0BAAgB,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,CAAC;oBAErD,IAAI,CAAC,SAAS,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE;wBACrC,SAAS;qBACV;iBACF;gBAED,IAAI,sBAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;oBAC3D,MAAM,CAAC,cAAc,CAAC,WAAW,EAAE,GAAG,EAAE,WAAI,CAAC,KAAK,EAAE,GAAG,EAAE,UAAU,CAAE,CAAC,CAAC;oBACvE,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;iBACrB;aACF;SACF;QAED,KAAK,GAAG,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;KACtC;AACH,CAAC;AAGD,kBAAe,OAAO,CAAC","sourcesContent":["import { isFunction } from 'lodash-es';\r\nimport { InstanceChainMap } from './factory';\r\nimport { Bind } from './bind';\r\n\r\n/**\r\n * Binds methods of an object to the object itself, overwriting the existing method.\r\n * @export\r\n * @param {string[]} [methods=[]]\r\n * @returns {ClassDecorator}\r\n * @example\r\n *\r\n * @BindAll()\r\n * class MyClass {\r\n *   bound() {\r\n *     return this;\r\n *   }\r\n *\r\n *   unbound() {\r\n *     return this;\r\n *   }\r\n * }\r\n *\r\n * const myClass = new MyClass();\r\n *\r\n * myClass.bound.call(null); // => MyClass {}\r\n * myClass.unbound.call(null); // => MyClass {}\r\n */\r\nexport function BindAll(methods: string[] = []): ClassDecorator {\r\n  return (target: any) => {\r\n    bindAllMethods(target, methods);\r\n  };\r\n}\r\n\r\nfunction bindAllMethods(target: Function, methods: string[] = []): void {\r\n  const targetProto = target.prototype;\r\n  let proto = target.prototype;\r\n  const boundKeys: string[] = [];\r\n\r\n  while (proto && proto !== Object.prototype) {\r\n    for (const key of Object.getOwnPropertyNames(proto)) {\r\n      const include = methods.length ? methods.indexOf(key) !== -1 : true;\r\n      const descriptor = Object.getOwnPropertyDescriptor(proto, key);\r\n\r\n      if (include && key !== 'constructor') {\r\n        // If this property is a getter and it's NOT an instance decorated\r\n        // method, ignore it. Instance decorators are getters until first accessed.\r\n        if (descriptor.get) {\r\n          const chainData = InstanceChainMap.get([proto, key]);\r\n\r\n          if (!chainData || !chainData.isMethod) {\r\n            continue;\r\n          }\r\n        }\r\n\r\n        if (isFunction(proto[key]) && boundKeys.indexOf(key) === -1) {\r\n          Object.defineProperty(targetProto, key, Bind(proto, key, descriptor)!);\r\n          boundKeys.push(key);\r\n        }\r\n      }\r\n    }\r\n\r\n    proto = Object.getPrototypeOf(proto);\r\n  }\r\n}\r\n\r\nexport { BindAll as bindAll };\r\nexport default BindAll;\r\n"]}