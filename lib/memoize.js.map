{"version":3,"file":"memoize.js","sourceRoot":"","sources":["../src/memoize.ts"],"names":[],"mappings":";;AACA,uCAAoC;AAEpC,qCAKmB;AACnB,6CAAkD;AAGlD;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACU,QAAA,OAAO,GAAG,0BAAgB,CAAC,uBAAuB,CAC7D,IAAI,yBAAe,CAAC,mBAAO,EAAE,IAAI,+BAAiB,EAAE,EAAE,EAAE,cAAc,EAAE,IAAI,EAAE,CAAC,CACP,CAAC;AACvD,kBAHP,eAAO,CAGO;AAC3B,kBAAe,eAAO,CAAC","sourcesContent":["\r\nimport { memoize } from 'lodash-es';\r\n\r\nimport {\r\n  DecoratorConfig,\r\n  DecoratorFactory,\r\n  ResolvableFunction,\r\n  BiTypedMethodDecorator1\r\n} from './factory';\r\nimport { MemoizeApplicator } from './applicators';\r\nimport { MemoizeConfig } from './shared';\r\n\r\n/**\r\n * Creates a function that memoizes the result of func. If resolver is provided,\r\n * it determines the cache key for storing the result based on the arguments provided to the memoized function.\r\n * By default, the first argument provided to the memoized function is used as the map cache key.\r\n * The func is invoked with the this binding of the memoized function.\r\n *\r\n * You can use a Function or a string that references a method on the class as the resolver.\r\n * You can also use a configuration object that lets provide a prexisting cache or specify\r\n * the map type to use.\r\n *\r\n * @example\r\n *\r\n * class MyClass {\r\n *   @Memoize({ type: WeakMap })\r\n *   getName(item) {\r\n *     return item.name;\r\n *   }\r\n *\r\n *   @Memoize('getName')\r\n *   getLastName(item) {\r\n *     return item.lastName;\r\n *   }\r\n * }\r\n */\r\nexport const Memoize = DecoratorFactory.createInstanceDecorator(\r\n  new DecoratorConfig(memoize, new MemoizeApplicator(), { optionalParams: true })\r\n) as BiTypedMethodDecorator1<ResolvableFunction | MemoizeConfig<any, any>>;\r\nexport { Memoize as memoize };\r\nexport default Memoize;\r\n"]}